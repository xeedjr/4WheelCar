//.$file${.::SensorsAO.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: SensorsAO.qm
// File:  ${.::SensorsAO.cpp}
//
// This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//
//.$endhead${.::SensorsAO.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp" // QP/C++ framework API
#include "SensorsAO.h"

using namespace QP;

// ask QM to define the Blinky class (including the state machine) -----------
//.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//. Check for the minimum required QP version
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 6.8.0 or higher required
#endif
//.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//.$define${sensors::SensorsAO} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace sensors {

//.${sensors::SensorsAO} .....................................................
//.${sensors::SensorsAO::SensorsAO} ..........................................
SensorsAO::SensorsAO()
  : QActive(Q_STATE_CAST(&SensorsAO::initial))
{}

//.${sensors::SensorsAO::SM} .................................................
Q_STATE_DEF(SensorsAO, initial) {
    //.${sensors::SensorsAO::SM::initial}
    return tran(&initialize);
}
//.${sensors::SensorsAO::SM::initialize} .....................................
Q_STATE_DEF(SensorsAO, initialize) {
    QP::QState status_;
    switch (e->sig) {
        //.${sensors::SensorsAO::SM::initialize}
        case Q_ENTRY_SIG: {
            POST(Q_NEW(Event, INITIALIZE_SIG), this);
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${sensors::SensorsAO::SM::initialize::INITIALIZE}
        case INITIALIZE_SIG: {
            status_ = tran(&WaitAPI);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}
//.${sensors::SensorsAO::SM::WaitAPI} ........................................
Q_STATE_DEF(SensorsAO, WaitAPI) {
    QP::QState status_;
    switch (e->sig) {
        //.${sensors::SensorsAO::SM::WaitAPI}
        case Q_ENTRY_SIG: {
            initialize(e);
            /// Should be after initializing IMU works very slow
            sonic_timeEvt.armX(TICKS_TIMEOUT_SEC/10, TICKS_TIMEOUT_SEC/10);
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${sensors::SensorsAO::SM::WaitAPI::IMU_DATA_READY}
        case IMU_DATA_READY_SIG: {
            imu_loop(e);
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${sensors::SensorsAO::SM::WaitAPI::SONCI_TIMEOUT}
        case SONCI_TIMEOUT_SIG: {
            sonic_process(nullptr);
            status_ = Q_RET_HANDLED;
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

} // namespace sensors
//.$enddef${sensors::SensorsAO} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
